---
layout:     post
title:      "深入JS正则先行断言"
subtitle:   "无序匹配的妙招"
date:       2018-04-24
author:     "Shany"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - JavaScript 
    - 正则表达式 
---

> This document is not completed and will be updated anytime.


# 目录

1. [前向匹配](#前向匹配)
2. [示例](#示例)
3. [参考资料](#参考资料)


# 前向匹配

前向匹配也叫先行断言、前瞻匹配、前瞻表达式、正向前瞻。
正向前瞻语法为(?=pattern),即在目标字符串的相应位置必须有pattern部分匹配的内容，但不作为匹配结果处理
因为它不会改变当前正则的lastIndex，所以对‘是否有’这样不关心的顺序的匹配需求特别合适。

# 示例
前相匹配是为了应对正则无序匹配的场景的，例如简单密码验证
1. 6到10个单字字符 \w
2. 至少包含一个小写字母 [a-z]
3. 至少包含一个大写字母 [A-Z]
4. 至少包含一个数字 \d


条件1： [0-9|a-z|A-Z]{6,}
条件2： (?=.*[a-z])
条件3： (?=.*[A-Z])
条件4： (?=.*[0-9])

结果是
```js
let pwReg =/^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])[0-9|a-z|A-Z]{6,}$/
```
就这个正则，说说<b>我对前瞻匹配的理解。</b><br/>
以条件2为例：
(?=.*[a-z]) ，按照前瞻匹配的定义，这是说0个或多个任意字符之后，有一个小写字母。为么要在小写字母前匹配0个或多个任意字符呢？
举例
```js
/(?=s)(?=i).*/g.test('ertgsfgdfgid') // false
```
因为这里的意思是匹配任意一个字符，它后面跟的既是s也是i，这是不可能的
```js
 /(?=s)(?=.*i).*/g.test('ertgsfgdfgid')  // true
```
因为前瞻不改变匹配位置，通俗说叫‘不吃字符’，所以实际的匹配的字符是‘.*’完成的，它意思是任意字符，在它之前加了一个前瞻，意思是这个任意字符有s，且从匹配s的一点往后，它也匹配.*i,实际上就是含有i的意思。相应的我们可以看它的匹配结果
```js
'ertgsfgdfgid'.match(/(?=s)(?=.*i).*/g) // ["sfgdfgid"]
```
所以如果我们要匹配一个既包含s也包含i的字符串，正则应该这样写：
```js
/(?=.*s)(?=.*i).*/g.test('ertgsfgdfgid')
```
所以如果我们要匹配含有小写字母，正则是(?=.*[a-z])

# 参考资料

[JS 正则表达式否定匹配（正向前瞻）](https://www.cnblogs.com/dong-xu/p/6926064.html)
[深入JS正则先行断言](https://www.cnblogs.com/JuFoFu/p/8267184.html)

